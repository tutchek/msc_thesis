\newpage

\label[chap:model]
\chap Algorithms for automated logistics

\pozn{Zkontrolovano: ne}In this chapter we propose algorithms for ALP, as defined in chapter \ref[chap:analysis].

\sec Preliminary tasks

In this section we summarize the tasks, which must be performed prior to running an actual algorithm solving ALP

\secc Schema of the system

The whole process is directed by documents in the ERP system. The system will first get information from the ERP system, plan new transfers and produce new documents to the ERP system. 
The basic schema of the algorithm is shown on the Figure \ref[fig:algorithm:basic-schema].

\begfigure
\centerline{\inspic figs/algorithm-basic-schema-1.pdf }\nobreak\medskip
\label[fig:algorithm:basic-schema]\caption/f Basic schema of the algorithm
\endfigure

In general, the system performs the following steps:

\begitems \style N
* The system loads data from the ERP. It gets the information about pending transfers, availability of goods and demands for goods 
* Afterwards, it receives demands from an external software system responsible for balancing the goods on stores.
* Then, the system uses one of the algorithms to plan the transfers of goods to meet the requirements.
* Finally, the system generates or alters the documents in ERP to perform plans generated in the Step 3.
\enditems

\secc Delivery time

For the purposes of proper planning, we need to estimate a duration of planned transfers. After the system creates a shipment order, an employee must process it. They must search for the demanded goods
in the store, pack it and hand it over to a delivery company. As described in section \ref[sec:analysis:pickup], the delivery company stops only once in a while. If the goods is not prepared in time for
the pick-up, it will be handed over on the next pick-up. To compute a delivery time, we use the algorithm \ref[alg:algorithm:delivery-time].

\begfigure
\begalgo
\+{\bf function} \uppercase{delivery--time}($path$, $time$)\cr
\+\kern2cm{\bf returns} a delivery time after transferring goods along the path\cr
\+\quad\cleartabs&\bf variables: &$path$\hbox to2em{\dotfill}&a sequence of stores $s$ from the origin store $s_0$ to the\cr
\+               &            &        &destination store $s_n$.\cr
\+               &            &$time$\dotfill&a shipment time\cr
\+               &            &$T$\dotfill&a computed total time, initially zero\cr
\+               &                               &$s$\dotfill&currently examined store\cr
\+               &                               &$s'$\dotfill&temporary variable containing\cr
\+               &                               &                &a next store on the path\cr
\+\cr
\penalty-100
\+               &$T\leftarrow time$\cr
\+               &$s\leftarrow$ first store on $path$\cr
\+               &{\bf while} $s\neq \mathbox{last store on } path$ {\bf do:}\cr
\+               &\quad\cleartabs&$s'\leftarrow \mathbox{next store on $path$ after $s$}$\cr
\label[alg:algorithm:delivery-time:a1]
\+               &               &$T\leftarrow T + \mathbox{time needed to prepare shipment in $s$ at $T$}$\cr
\+               &               &$T\leftarrow \mathbox{next pick-up time at $s$ in direction to $s'$ after $T$}$\cr
\label[alg:algorithm:delivery-time:a2]
\+               &               &$T\leftarrow T + \mathbox{transport duration from $s$ to $s'$ at $T$}$\cr
\+               &               &$T\leftarrow \mathbox{next delivery time at $s'$ in direction from $s$ after $T$}$\cr
\label[alg:algorithm:delivery-time:a3]
\+               &               &$T\leftarrow T + \mathbox{time needed to recieve shipment in $s'$ at $T$}$\cr
\+               &               &$s\leftarrow s'$\cr
\+               &\bf end while\cr
\+\cr
\+               &\bf return $T$\cr
\endalgo\nobreak\medskip
\label[alg:algorithm:delivery-time]\caption/a Algorithm for computing the delivery time 
\endfigure

The delivery companies as well as stores do not operate during weekends and public holidays. The algorithm \ref[alg:algorithm:delivery-time] take into account this condition on the lines 
\ref[alg:algorithm:delivery-time:a1], \ref[alg:algorithm:delivery-time:a2] and \ref[alg:algorithm:delivery-time:a3], since the prolongation is included in the delivery time and time
needed to prepare and receive a shipment.

\label[sec:algorithm:queue-jumping]
\secc Recovering from the queue jumping

When a salesman jumps the queue, they remove an item reserved for a certain customer or planned for a transfer. Therefore, we must recover from a situation when the transfer is planned but there
is no goods available. First, we must detect whether there was any goods planned for a transfer but is currently unavailable and perform a specific action. Thus, we check all goods on unresolved shipment orders using algorithm \ref[alg:algorithm:is-available].

\begfigure
\begalgo
\+{\bf function} \uppercase{SO--available}($shipment\_order$, $commodity$) \cr
\+\kern2cm{\bf returns} \cleartabs&available amount of $commodity$ on $shipment\_order$\cr
\+\cr
\+\quad\cleartabs&\bf variables: &$shipment\_order$\algfill\cleartabs&a shipment order to be checked\cr
\+               &            &$commodity$\dotfill&a type of goods\cr
\+               &               &$s$\dotfill&a store related to $shipment\_order$\cr
\+               &                               &$onStock$\dotfill&amount of $commodity$ present at $s$\cr
\+               &                               &$ordered$\dotfill&amount of $commodity$ on $shipment\_order$\cr
\+               &                               &$blocked$\dotfill&amount of $commodity$ blocked by\cr
\+               &                               &                     &previous shipment orders\cr
\+               &                               &$available$\dotfill&amount of $commodity$ available at $s$, \cr
\+\cr
\+               &$s \leftarrow \mathbox{get store from $shipment\_order$}$\cr
\+               &$onStock \leftarrow \mathbox{amount of $goods$ on stock at $s$}$\cr
\+               &$ordered \leftarrow \mathbox{amount of $goods$ on $shipment\_order$}$\cr
\+               &$blocked \leftarrow $\cleartabs&$\mathbox{amount of $goods$ on shipment orders}$\cr
\+               &                              &$\mathbox{older than $shipment\_order$ at $s$}$\cr
\+               &$available \leftarrow onStock - blocked$\cr
\+\cr
\+               &{\bf if} $available \leq 0$ {\bf then}\cr
\+               &\quad\cleartabs&{\bf return} 0\cr
\+               &{\bf else if} $available \geq ordered$ {\bf then}\cr
\+               &&{\bf return} $ordered$\cr
\+               &{\bf else}\cr
\+               &&{\bf return} $available$\cr
\+               &{\bf end if}\cr
\endalgo\nobreak\medskip
\label[alg:algorithm:is-available]\caption/a Algorithm computing the available amount of goods for a given shipment order.
\endfigure

If the amount of available items is smaller than the ordered amount, the shipment order cannot be processed. We could send the missing goods from another store, if available, but it is not effective since
it would be better to transfer it from the store directly to a destination store of the shipment order. Therefore, the shipment order should be at least partially cancelled. This situation can be 
handled in two different ways. The simple solution is to do nothing. The transfer order was generated due to a demand from some other store. Therefore, if the demand is still valid it will be executed in the next 
run of the planning algorithm, if possible. Even though the original demand is delayed, at least it will be processed sometime in the future and will not wait until the goods will be replenished.

The second option to solve the missing goods is to rearrange other planned transfers which were set after the affected shipment order. Unfortunately, we cannot simply change the destination of a transfer.
Each document is identified by series of documents and a sequence number which are unchangeable. The serie number carries an information about the type of the document. Moreover, in case of transport shipment
orders, each serie is assigned to a pair of stores; the original and the destinated store. Therefore, we need to create a new document instead of changing the original one. However, this would not solve the 
problem since the shipment orders are processed in the order of their creation. As a result, we refuse this solution.

\secc Recovering from the store outage

When a store outage occurs, the respective store cannot send or receive goods. In case of planned outages, they can be taken into account in the algorithm \ref[alg:algorithm:delivery-time] for new
transfers, since it is the same situation as weekends or public holidays. However, we still need to handle unprocessed transfers planned before the outage. If we are able to estimate a duration of the outage,
we can check if it is possible to transfer the goods from another store faster. In such a case, we will cancel the shipment order in the outaged store and place a new shipment order in the other store. Nothing, however, can be done concerning other situations. If we do not know the estimated duration of the outage, we can use a predefined universal duration (e.g. two weeks) or we can simply deal with the situation in the same way as in the case 
of queue jumping described in section \ref[sec:algorithm:queue-jumping], because the goods on the shipment order is effectively missing.

\label[sec:analysis:naive]
\sec Na\I ve algorithm

In this section, we will describe a na\I ve algorithm for ALP. This algorithm only covers the current insufficiency in stores and does not respect an order of 
precedence of shipment orders. However, this approach is still reasonable if there is enough goods in other stores and if we run the algorithm regularly. Even though the algorithm
itself does not maintain an order of demands (i.e. the constraint \ref[eq:analysis:alp-c3] on page \pgref[eq:analysis:alp-c3]), if it is run regularly in a small time steps, the constraint 
will be satisfied implicitly. The order will not be maintained only for the demands which arise between the time steps. The shorter the time step is, the lesser amount of demands is affected.
The algorithm does not deal with capacity constraints. Therefore, it is not suitable for ALP-lp and ALP-lp2.

For each type of goods, the algorithm divides stores into two groups according to the available amount of the goods. The first group of stores $S$ (source stores) contains stores where 
the available amount of goods is positive. The second group of stores $D$ (destination stores) contains stores where the available amount of goods is negative.

The algorithm is run separately for each type of goods. The algorithm picks up the first store in $D$ and searches for the fastest transfer from a store in $S$. The algorithm is listed in detail as an 
algorithm \ref[alg:algorithm:naive].

The na\I ve algorithm is used to compare the Ford-Fulkerson based, CSP based, and MIP based algorithms with a trivial solution of ALP.

\begfigure
\begalgo
\+{\bf function} \uppercase{plan--transfers--naive}($commodity$, $stores$)\cleartabs&\cr
\+\cr
\+\quad\cleartabs&{\bf variables:} \cleartabs&$commodity$\algfill&a type of goods\cr
\+               &                           &$stores$\dotfill&a set of stores\cr
\+               &                           &$strengths$\dotfill&a set of sales strengths for each store\cr
\+               &                           &$Availability_s$\dotfill&availability of $commodity$ in store $s$\cr
\+               &                                 &$Availability^*_s$\dotfill&availability of $commodity$ in store $s$\cr
\+               &                                 &                              &including goods on the way\cr
\+               &                                 &$S$\dotfill&a set of source stores\cr
\+               &                                 &$D$\dotfill&a set of destination stores\cr
\+               &                                 &$s_s,s_d$\dotfill&source and destination stores\cr
\+               &                                 &$missing$\dotfill&a current amount of missing items\cr
\+               &                                 &                     &of $commodity$\cr
\+               &                                 &$toTransfer$, an amount of $commodity$ to be transferred\cr
\+\cr
\+               &$S \leftarrow \{s_s | s \in stores, Availability_{s_s} > 0\}$\cr
\+               &$D \leftarrow \{s_d | s\in stores, Availability^*_{s_d} < 0\}$\cr
\+               &{\bf for each} store $s_d\in D$ {\bf do:}\cr
\+               &\quad\cleartabs&{\bf while} $Availability^*_{s_d} < 0$ {\bf do:}\cr
\+               &               &\quad\cleartabs&$s_s\leftarrow \mathbox{origin of }\left(\argmin_{path \mathbox{ from } S \mathbox{ to } s_d}\left\{\mathbox{\uppercase{delivery--time}}(path, now)\right\}\right)$\cr
\+               &               &               &{\bf if} $s_s = null$ {\bf then}\cr
\+               &               &               &\quad\cleartabs&{\bf break while}\cr
\+               &               &               &{\bf end if}\cr
\+               &               &               &$missing \leftarrow - Availability^*_{s_d}$\cr
\+               &               &               &$toTransfer \leftarrow \min{\{missing, Availability_{s_s} \}}$\cr
\+               &               &               &\uppercase{plan-transfer}$(commodity, s_s, s_d, toTransfer)$\cr
\+               &               &               &$Availability^*_{s_d} \leftarrow Availability^*_{s_d} + toTransfer$\cr
\+               &               &               &$Availability_{s_s} \leftarrow Availability_{s_s} - toTransfer$\cr
\+               &               &               &{\bf if} $Availability_{s_s} = 0$ {\bf then} $S = S \setminus \{s_s\}$ {\bf end if}\cr
\+               &               &{\bf end while}\cr
\+               &{\bf end for}\cr
\endalgo\nobreak\medskip
\label[alg:algorithm:naive]\caption/a Na\I ve algorithm for automated logistics.
\endfigure

\label[secc:analysis:ford-fulkerson]
\sec Ford-Fulkerson based algorithm

The more advanced algorithm is based on the Ford-Fulkerson algorithm described in section \ref[sec:research:network-flows]. This algorithm solves an ALP problem while maintaining the order of demands.
However, it is not able to handle constraints preventing overloading.  

For each goods we construct a graph as showed on Figure \ref[fig:algorithm:ford-fulkerson]. The capacities of edges from the source corresponds to the amount of available goods in the particular store
and the capacities of edges to the destination corresponds to the demanded amount of goods in the stores.
Then we use the Ford-Fulkerson algorithm, to find the maximal flow through the network. Augmenting paths generated by the algorithm are then transformed to documents in ERP. The algorithm differs from 
the original algorithm in a way, in which it selects an augmenting path to be added. First, we process demands in their orders. For each demand, we search for a suitable path with the shortest duration.
Since the original Ford-Fulkerson algorithm allows us to place augmenting paths in any order and finds the maximal flow through network, it is guaranteed that our algorithm finds the maximal flow
in the network as well. Moreover, by proper selection of paths to be added, it 

\begfigure
\centerline{\inspic figs/algorithm-ford-fulkerson-1.pdf }\nobreak\medskip
\label[fig:algorithm:ford-fulkerson]\caption/f A bipartite graph construed for the Ford--Fulkerson based algorithm. There are five stores $s_n$ with the amount of available goods $a_n$ and the demanded amount $d_n$. The augmenting path $({\bf 0}, s_2, s_4, {\bf 1})$ is highlighted. All edges have left-to-right direction. We did not draw the edges as arrows since due to to their count, it would become 
hard to read the picture.
\endfigure

Now we describe the algorithm in a detail. The Ford-Fulkerson finds the maximum flow in a given network. It searches for augmenting paths from the source to the sink of the network. An augmenting path is a path where all of its 
edges are not fully saturated. Thus, we can increase the flow through the network along the path. The new flow cannot exceed the capacity of any edges on the path.

For each type of goods, we construct a bipartite graph $G=({\bf V},{\bf E})$ consisting of a set of source stores ${\bf S}$ and a set of destination stores ${\bf D}$. Moreover, we add dummy nodes 
${\bf 0}$ and ${\bf 1}$ representing the source and the sink of the network. The following conditions hold:

$${\bf V} = {\bf S} \cup {\bf D} \cup \{{\bf 0},{\bf 1}\} \eqmark$$

$${\bf S} \cap {\bf D} = \emptyset \eqmark$$

$$\{{\bf 0}, {\bf 1}\} \cap \left( {\bf S}\cup {\bf D} \right) = \emptyset \eqmark$$

$${\bf E} = \{({\bf 0}, s)| s \in {\bf S}\} \cup \{(s_s, s_d) | s_d \in {\bf S}, s_d \in {\bf D}\} \cup \{(s, {\bf 1}) | s \in {\bf D}\} \eqmark$$

For each possible delivery route between the stores $s_s \in S$ and $s_d \in D$ there is an edge $(s_s, s_d) \in E$ with an unlimited capacity. Finally, for each node $s_s \in S$ there is an edge 
$(0,s_s)\in E$ with capacity representing the amount of available goods in store $s_s$. Similarly, for each node $s_d \in D$ there is an edge $(s_d,1) \in E$ with capacity representing the
demanded amount of goods in store $s_d$. We allow only integer flows.


As we mentioned earlier, the Ford--Fulkerson algorithm finds the maximum flow by placing augmenting paths until no other path can be placed without violating the capacity 
constraints. We generate shipment orders from the generated augmenting paths. Each path from $s_s$ to $s_d$ with a flow $f$ is transformed to a shipment order for a transfer 
of $f$ items of goods from store $s_s$ to store $s_d$, if $s_s \neq s_d$.

The key part of the algorithm is an order in which the augmenting paths are tested and placed. As we defined in section \ref[sec:analysis:alp], a demand is a 4-tuples $(s, g, amount, date)$. We sort 
all demands $d \in {\bf D}$ according to their $date$ in ascending order. Next, we process the demands in their order and try to place the augmenting paths. For each demand, we generate feasible paths 
in a graph and select the path with the earliest delivery time (algorithm \ref[alg:algorithm:delivery-time] on page \pgref[alg:algorithm:delivery-time]). The pseudo-code of the algorithm is presented 
as Algorithm \ref[alg:algorithm:ford-fulkerson] on page \pgref[alg:algorithm:ford-fulkerson].

\begfigure
\begalgo
\+{\bf function} \uppercase{plan--transfers-ff}($g$, $D$, $S$)\cr
\+\cr
\+\quad\cleartabs&{\bf variables:} \cleartabs&$g$\algfill&a goods\cr
\+               &                           &$s$\dotfill&a set of stores\cr
\+               &                           &$D$\dotfill&a set of demands\cr
\+               &                           &$V$\dotfill&a set of nodes of a construed graph\cr
\+               &                           &$E$\dotfill&a set of edges of a construed graph\cr
\+               &                           &$cap$\dotfill&a capacity function of a construed graph\cr
\+               &                           &$d$\dotfill&one particular demand\cr
\+               &                           &$s, s'$\dotfill&stores\cr
\+               &                           &$amount$\dotfill&an amount of $commodity$ on\cr
\+               &                           &                &a shipment order\cr
\+               &                           &$i$\dotfill&a dummy iteration variable\cr
\+               &                           &$paths$\dotfill&a set of paths\cr
\+               &                           &$p$\dotfill&a path consisting of nodes $p_1$, ..., $p_n$\cr
\+\cr
\+               &sort $D$ by $date$ in ascending order\cr
\+               &$V \leftarrow \left(S \times \{s,d\}\right) \cup \{{\bf 0},{\bf 1}\}$\cr
\+               &$E \leftarrow \emptyset$\cr
\+               &{\bf for each} $s \in S$ {\bf do:}\cr
\+               &\cleartabs\quad&$E \leftarrow E \cup \{({\bf 0},s_s), (s_d, {\bf 1})\}$\cr
\+               &               &$cap({\bf 0}, s_s) \equiv \max\{0, Availability_{g,s}\}$\cr
\+               &               &$cap(s_d, {\bf 1}) \equiv \max\{0, -Availability^*_{g,s}\}$\cr
\+               &               &{\bf for each} $s' \in S$ {do:}\cr
\+               &               &\quad\cleartabs&$E\leftarrow E\cup\{(s_s,{s'}_d)\}$\cr 
\+               &               &\quad\cleartabs&$cap(s_s,{s'}_d)\equiv \infty$\cr 
\+               &               &{\bf end for}\cr
\+               &{\bf end for}\cr
\+               &{\bf for each} $d \in D$ {\bf do:}\cr
\+               &\cleartabs\quad&{\bf if} $goods(d) \neq g$ {\bf then} skip the iteration and proceed with another $d$ {\bf end if}\cr
\+               &               &$s \leftarrow store(d)$\cr
\+               &               &$amount \leftarrow amount(d)$\cr
\+               &               &{\bf for} $i$ = 1 {\bf up to} $amount$ {\bf do:}\cr
\+               &               &\quad\cleartabs&$paths \leftarrow \{({\bf 0}, s_s, s, {\bf 1}) | cap({\bf 0}, s_s) > 0 \wedge cap(s_s, s) > 0 \wedge cap(s, {\bf 1}) > 0\}$\cr
\+               &               &               &{\bf if} $paths = \emptyset$ {\bf then}\cr
\+               &               &               &\quad\cleartabs&{\bf break}\cr
\+               &               &               &{\bf end if}\cr
\+               &               &               &$p\leftarrow \argmin_{p \in paths}\left\{\mathbox{\uppercase{delivery--time}}(p, now)\right\}$\cr 
\medskip
\+               &               &               &\uppercase{plan-transfer}$(commodity, p_2, s, 1)$\cr
\+               &               &               &$cap({\bf 0}, p_2) \equiv cap({\bf 0}, p_2)-1$\cr
\+               &               &               &$cap(p_2, p_3) \equiv cap(p_2, p_3)-1$\cr
\+               &               &               &$cap(p_3, {\bf 1}) \equiv cap(p_3, {\bf 1})-1$\cr
\+               &               &{\bf end for}\cr
\+               &{\bf end for}\cr
\endalgo\nobreak\medskip
\label[alg:algorithm:ford-fulkerson]\caption/a Ford-Fulkerson based algorithm.
\endfigure

\label[model:sec:csp]
\sec CSP model

We propose a model based on the path-based model described in section \ref[sec:models:networks]. As we have mentioned, we are not limited by the capacity of edges and we plan to transfer lots of
types of goods at once. However, we need to prevent overloading of stores. Therefore, we chose a path-based model and we propose a CSP model based on it. The model solves both ALP and ALP-lp.
Since the ALP-lp is a multiple-criteria optimization problem, the model depends on two parameter $\alpha$ and $\beta$, one for each goal of ALP-lp.

\begitems 
* ${\bf S}$, a set of stores.
* ${\bf G}$, a set of goods.
* ${\bf D}$, a set of demands. When a demand $i$ has been placed before a demand $j$, it holds that $i < j$. 
* ${\bf P}$, a set of all possible paths between stores.
* ${\bf T}$, a set of time events.
* ${\rm Orig} \colon {\bf P} \rightarrow {\bf S}$, a function returning an origin store of a given path.
* ${\rm Dest} \colon {\bf P} \rightarrow {\bf S}$, a function returning a destination store of a given path.
* ${\rm Amount} \colon {\bf D}\times{\bf G} \rightarrow {\bbchar N}_0$, a function returning an amount of goods demanded by a given demand.
* ${\rm Availability} \colon {\bf G} \times {\bf S} \rightarrow {\bbchar Z}$, a function returning an amount of goods available in a given store. It is a difference between $OnStock$ and a sum of all demands on a given store for the goods.
* ${\rm Capacity} \colon {\bf S} \rightarrow {\bbchar N}$, a function returning a daily capacity of a given store.
* ${\rm Duration} \colon {\bf P} \rightarrow {\bf T}$, a function returning a time needed to transfer goods along the path, when send right after the execution of the algorithm.
* ${\rm OnTheWay} \colon {\bf G} \times {\bf S} \rightarrow {\bbchar N}_0$, a function returning an amount of goods which is delivered to a given store.
* ${\rm Pri} \colon {\bf D} \rightarrow \{{\rm high}, {\rm low}\}$, a function returning a priority for a given demand.
* ${\rm Time} \colon {\bf P}\times{\bf S}\rightarrow{\cal P}({\bf T})$, a function returning for a given store and path days when the goods sent along the path will be in the store. 
\enditems

Next, we introduce constrained variables:

\nobreak
\begitems
* $X^g_{dp}\in \{0,1\}$, a decision variable representing whether the demand $d$ for a goods $g$ is at least partially transferred along the path $p$.
* $Y^g_{dp}\in {\bbchar N}_0$, a variable containing an amount of goods $g$ for a demand $d$ transferred along a path~$p$.
* $Z_d^g \in {\bbchar N}_0$, a variable containing a total amount of goods transferred for a demand~$d$. 
\enditems

The CSP model consists of an objective function

\label[model:constraint:of]
$$\min\left\{\alpha\sum_{g\in {\bf G}}\sum_{d \in {\bf D}}\sum_{p \in {\bf P}}{X^g_{dp}{\rm Duration}(p)} - \beta \sum_{g \in {\bf G}}\sum_{d \in {\bf D}}\sum_{p \in {\bf P}}{Y^g_{dp}}\right\}
\eqmark$$

\noindent and following constraints:

\label[model:constraint:availability]
$$\forall g \in {\bf G},\forall s \in {\bf S} \colon \sum_{d \in {\bf D}}\sum_{\scriptstyle p \in {\bf P} \atop\scriptstyle s = {\rm Orig}(p)}{\hskip-1emY_{dp}^g} \leq {\rm Availability}(g,s)\eqmark$$

\label[model:constraint:destination]
$$\forall g\in{\bf G},\forall d \in {\bf D}, \forall p \in {\bf P}, {\rm Dest}(p) \neq {\rm Dest}(d)\colon Y_{dp}^g = 0\eqmark$$

\label[model:constraint:demand-sum]
$$\forall g \in {\bf G}, \forall d \in {\bf D}\colon Z_{d}^g = \sum_{p \in P}{Y_{dp}^g}\eqmark$$

\label[model:constraint:demand-limit]
$$\forall g \in {\bf G}, \forall d \in {\bf D}\colon Z_{d}^g \leq {\rm Amount}(d, g)\eqmark$$

\label[model:constraint:decision]
$$\forall g \in {\bf G}, \forall d \in {\bf D}, \forall p \in {\bf P}\colon Y_{dp}^g > 0 \Leftrightarrow X^g_{dp} = 1 \eqmark$$

\penalty-500
\label[model:constraint:order]
% $$\forall g \in {\bf G},\forall s \in {\bf S},\forall d \in {\bf D}, d > 1: Z_{d}^g > 0 \Rightarrow \hskip\displaywidth minus 1fill$$
% $$\hskip\displaywidth minus1fill\Rightarrow {\rm OnTheWay}(g,s) + \sum_{\scriptstyle i \in {\bf D}, i < d\atop\scriptstyle {\rm Pri}(i)={\rm high}}\sum_{\scriptstyle p \in {\bf P}\atop\scriptstyle 
% s = Dest(p)}{\hskip-1emY_{ip}^g} \geq \sum_{\scriptstyle i \in {\bf D}, i < d \atop {\scriptstyle s=Dest(i)\atop\scriptstyle {\rm Pri}(i)={\rm high}}}{\hskip-1em{\rm Amount}(i, g)} \eqmark$$


$$ \forall g \in {\bf G}, \forall s \in {\bf S}, \forall d \in {\bf D}, d > \min\bigl\{i | i\in {\bf D}, {\rm Amount}(i,g) > 0, s = {\rm dest}(i)\bigr\}: \hskip\displaywidth minus 1fill$$
$$\hskip\displaywidth minus 1fill  Z_d^g > 0 \Rightarrow \hskip-1.5em\bigwedge_{\scriptstyle i \in {\bf D}, i < d \atop {\scriptstyle s={\rm Dest}(i)\atop{\scriptstyle {\rm Pri}(i)={\rm high}\atop
\scriptstyle {\rm Amount}(i,g) > 0}}}{\hskip-1.5em\left(Z_i^g = {\rm Amount}(i,g)\right)} \eqmark $$

\label[model:constraint:all]
$$\forall g \in {\bf G}:\hskip-1em\sum_{\scriptstyle d \in {\bf D}\atop\scriptstyle {\rm Pri}(d) = {\rm high}}{\hskip-1em Z^g_d} = \min\left\{\sum_{\scriptstyle s \in {\bf S}\atop\scriptstyle
{\rm Availability}(g,s) > 0}{\hskip-2em{\rm Availability}(g,s)},\hskip-1em\sum_{\scriptstyle d \in {\bf D}\atop\scriptstyle {\rm Pri}(d) = {\rm high}}{\hskip-1em{\rm Amount}(d,g)}\right\} 
\eqmark$$

\label[model:constraint:overload]
$$\forall s \in {\bf S}, \forall t \in {\bf T}: \sum_{g \in {\bf G}}\sum_{d \in {\bf D}}\sum_{\scriptstyle p \in {\bf P}\atop\scriptstyle t \in {\rm Time}(p,s)}{\hskip-1emY^g_{dp} \geq {\rm Capacity}(s)} 
\Rightarrow \sum_{g \in {\bf G}}\sum_{\scriptstyle p\in{\bf P}\atop\scriptstyle t \in {\rm Time}(p,s)}\sum_{\scriptstyle d \in {\bf D}\atop\scriptstyle{\rm Pri}(d) = {\rm low}}{\hskip-1emY^g_{dp}} = 0 \eqmark$$

First, we add a constraint \ref[model:constraint:availability] restricting the amount of goods which can be transferred from a particular store. The sum of the transferred amounts cannot exceed 
the available amount of the goods in the store.

Next, we will add a constraint \ref[model:constraint:destination] which allows to serve a demand only with paths which end in its destination node.

For the demands itself, we define constraints \ref[model:constraint:demand-sum] and \ref[model:constraint:demand-limit] which limit the total flow of goods based on the value of the demand.

For the objective function, as described below, it is useful to introduce a constraint \ref[model:constraint:decision], which allows us to detect used paths.

To enforce an order of precedence we introduce a constraint \ref[model:constraint:order]. We can plan a transfer for a demand only if all previous demands were resolved, i.e. the sum of goods which is 
currently on the way and of all already planned transfers for the goods covers at least the sum of demanded amount of goods on the demands.



Importantly, we must ensure that we will plan as many transfers as possible. Otherwise, the objective function \ref[model:constraint:of] would prefer the empty solution (which is the shortest possible).
Therefore, we introduce a constraint \ref[model:constraint:all].


Finally, we introduce a constraint \ref[model:constraint:overload] which prevents the overload of stores. Each store has a given daily capacity which should not be exceeded if possible. We can always plan a
high-priority transfer but we cannot plan a low-priority transfer through a store, if it would cause its overload.


For this model we introduce an objective function \ref[model:constraint:of]. There are two requirements for the solution. First, the final plan should be as fast as possible. Secondly, as many demands
as possible should be resolved. These two requirements are contradictory. If we decide to avoid all of the low-priority transfers, we will get faster plan than if we have resolved some of them.
On the other hand, if we decide to resolve as many as possible low-priority transfers, the resulting plan does not have to be the fastest one. Therefore, we introduce the parameters $\alpha$ and $\beta$.
We can use them to tune the model to our needs.


The model as proposed has one disadvantage. The number of constrained variables is huge even for small problems. The number of constrained variables is $O(|{\bf G}|\cdot|{\bf S}|^2\cdot|{\bf D}|)$,  
since there are $|{\bf G}|$ goods, $|{\bf S}|^2$ paths and $|{\bf D}|$ demands. However, we can radically decrease the number of constrained variables. We do not have to post variables 
which would clearly not be
satisfied. For example, the variable $Y_{dp}^g$ should be posted only if the demand $d$ demands a goods $g$ and if its store is the same as the destination store of $p$. Moreover, we should put into
a set ${\bf D}$ only demands, which could be potentially resolved (i.e. there is at least one item of goods available in stores) and into a set ${\bf G}$ put only goods which is requested by some of 
the demands already placed in ${\bf D}$.

\secc Variations of the CSP based model

The model as described in previous section solves both ALP and ALP-lp. If we need to solve only ALP, we can remove the constraint \ref[model:constraint:overload] and use a simplified objective function:

$$\min\left\{\sum_{g\in {\bf G}}\sum_{d \in {\bf D}}\sum_{p \in {\bf P}}{X^g_{dp}{\rm Duration}(p)} \right\} \eqmark$$

\noindent Alternatively, we can simply set the $\beta = 0$ and set the priority of all demands to {\em high}.

To model the ALP-lp2 model, we use the CSP based model as described in section \ref[model:sec:csp] add the ${\rm Penalty}$ function:

\begitems
* ${\rm Penalty} \colon {\bf D} \to {\bbchar N}$, a function returning a penalty for not scheduling a given low-priority demand.
\enditems

\noindent Next, we add a new decision variable:

\begitems
* $W^g_{d}\in \{0,1\}$, a decision variable representing whether the demand $d$ for a goods $g$ is at least partially resolved.
\enditems

\noindent For the new variable, we add a corresponding constraint:

$$\forall g \in {\bf G}, \forall d \in {\bf D}\colon Z_{d}^g > 0 \Leftrightarrow W^g_{d} = 1 \eqmark$$

\noindent Finally, we use a modified objective function:


$$\min\left\{\sum_{g\in {\bf G}}\sum_{d \in {\bf D}}\sum_{p \in {\bf P}}{X^g_{dp}{\rm Duration}(p)} + \sum_{g\in {\bf G}}\sum_{\scriptstyle d \in {\bf D}\atop \scriptstyle {\rm Pri}(d) = {\rm low}}{
\left( (1 - W^g_{d}) {\rm Penalty}(d) \right)}  \right\} \eqmark$$

\secc CSP solver

To implement the previously stated model, we use a state of the art CSP\glos{CSP}{Constraint satisfaction problem} solver. Nowadays, there are many solvers available but we sought for a cost optimal solution, which is preferably Java based, since it would easily merge with other Sunnysoft program environment. Therefore, based on the experiences in \cite[Tulacek2009] we used a Java based CSP solver 
Choco \cite[choco].

The proposed constraints can be directly rewritten in Choco. Thus, we did not need to reformulate the model to meet the available constraints. Still, there are some issues connected to the 
implementation. Some of them are discussed in the Appendix \ref[ap:implementation].

The solver offers us to choose a search strategies out of many predefined strategies or to implement own search strategy. By default, the solver uses a {\em minimum domain lower bound strategy} on all 
integer variables and {\em lexicographic upper bound strategy} on all binary variables. The minimum domain lower bound strategy selects a variable $x$ using the first-fail strategy, described in section 
\ref[sec:models:constraint-programming] and tries set its value to the lower bound of its domain, i.e. $x = lower\_bound(D_x)$. In the case of binary variables, all of them have a domain containing
one or two elements. Therefore, Choco solver does not use the first-fail strategy. Instead, it simply selects the variables in order, in which they were posted to the solver and tries to assign them
their current upper boundary.

The default strategy is usually not optimal, since it tries assign values to all variables, no matter of their importance for the problem. For example, in our CSP based model, we have to introduce
auxiliary variables, which hold results of the sum constraints. However, all of them depends exclusively on values of $Y^g_{dp}$. Therefore, we should alter the default strategy
to only search through $Y^g_{dp}$ variables, since all other variables in the problem are derived from them.

\sec MIP model

The model described in section \ref[model:sec:csp], is not the optimal model for CSP. In a typical CSP model, there is no problem with sum constraints. However, the model consist of sums almost
entirely. For such a model is the method not suitable. However, with a slight modification, we can reformulate it as a MIP problem. MIP solvers are optimized for sum constraints. Compared to CSP 
solvers, MIP solvers are more effective in this type of problem \cite[Carsten1995].

The model uses the same sets and functions, as the CSP model described in section \ref[model:sec:csp]. We reuse constrained variables $X^g_{dp}$, $Y^g_{dp}$ and $Z^g_d$ and add the following new
variables:

\begitems
* $W^g_{d}\in \{0,1\}$, a decision variable representing whether the demand $d$ for a goods $g$ is at least partially resolved.
* $U_{st}\in \{0,1\}$, a decision variable representing whether the store $s$ is overloaded at time $t$.
\enditems

The MIP model consists of an objective function

$$\min\left\{ \alpha \sum_{g \in {\bf G}}\sum_{d \in {\bf D}}\sum_{p \in {\bf P}} X^g_{dp}Duration(p) - \beta \sum_{g \in {\bf G}}\sum_{d \in {\bf D}}\sum_{p \in {\bf P}}{Y^g_{dp}} \right\} \eqmark$$

\noindent and following constraints:

$$\forall g \in {\bf G}, \forall s \in {\bf S}\colon \sum_{d \in {\bf D}}\sum_{p \in {\bf P}}{Y^g_{dp}} \leq Availability(g,s) \eqmark$$

$$\forall g \in {\bf G}, \forall d \in {\bf D}, \forall p \in {\bf P}, {\rm Dest}(d) \neq {\rm Dest}(p)\colon Y^g_{dp} = 0 \eqmark$$

$$\forall g \in {\bf G}, \forall d \in {\bf D}\colon Z^g_d = \sum_{p \in {\bf P}}{Y^g_{dp}} \eqmark $$

$$\forall g \in {\bf G}\colon \sum_{\scriptstyle d \in {\bf D}\atop \scriptstyle {\rm Pri}(d) = {\rm high}}{Z^g_d} = \min\left\{\sum_{\scriptstyle s \in {\bf S} \atop \scriptstyle 
{\rm Availability}(g,s) > 0}{\hskip-1em{\rm Availability}(g,s)} ; \sum_{\scriptstyle d \in {\bf D} \atop \scriptstyle {\rm Pri}(d) = {\rm high}}{\hskip-1em {\rm Amount}(d,g)}\right\}\eqmark$$

$$\forall g \in {\bf G}, \forall d \in {\bf D}\colon Z^g_d \leq {\rm Amount}(d,g)\eqmark$$

\label[eq:model:mip:xy:1]
$$\forall g \in {\bf G}, \forall d \in {\bf D}, \forall p \in {\bf P}\colon Y^g_{dp} \leq 0 + \mu X^g_{dp} \eqmark $$
\label[eq:model:mip:xy:2]
$$\forall g \in {\bf G}, \forall d \in {\bf D}, \forall p \in {\bf P}\colon -Y^g_{dp} \leq -1 + \mu (1- X^g_{dp}) \eqmark $$

$$\forall g \in {\bf G}, \forall d \in {\bf D}\colon Z^g_d \leq 0 + \mu W^g_d \eqmark $$
$$\forall g \in {\bf G}, \forall d \in {\bf D}\colon -Z^g_d \leq -1 + \mu (1- W^g_d) \eqmark $$

$$\forall g \in {\bf G}, \forall d \in {\bf D}, \exists d' \prec d, {\rm Pri}(d') = {\rm high}\colon \hskip\displaywidth minus 1fill$$
$$\hskip\displaywidth minus 1fill  -\hskip-1em\sum_{\scriptstyle d' \in {\bf D}\atop {\scriptstyle d' \prec d \atop\scriptstyle {\rm Pri(d')} = {\rm high}}}{\hskip-1em Z^g_{d'}} \leq 
-\hskip-1em\sum_{\scriptstyle d' \in {\bf D}\atop {\scriptstyle d' \prec d\atop\scriptstyle {\rm Pri(d')} = {\rm high}}}{\hskip-1em {\rm Amount}(d') + 
\mu(1-W^g_d)} \eqmark$$

$$\forall s \in {\bf S}, \forall t \in {\bf T}\colon \sum_{g \in {\bf G}}\sum_{d\in{\bf D}}\sum_{p \in {\bf P}}{Y^g_{dp}} \leq {\rm Capacity}(s) - 1 + \mu U_{st} \eqmark$$
$$\forall s \in {\bf S}, \forall t \in {\bf T}\colon \sum_{g \in {\bf G}}\sum_{d\in{\bf D}}\sum_{p \in {\bf P}}{Y^g_{dp}} \leq 0 + \mu(1- U_{st}) \eqmark$$

Most of the constraints are the same as in CSP based model. We will not repeat their description and only comment the new constraints.

The equations \ref[eq:model:mip:xy:1] and \ref[eq:model:mip:xy:2] enforce the condition $Y^g_{dp} > 0 \Leftrightarrow X^g_{dp} = 1$. We use here a trick, which enables to state a constraint that one of 
the conditions holds. It is either $Y^g_{dp} = 0 \wedge X^g_{dp} = 0$ or $Y^g_{dp} > 0 \wedge X^g_{dp} = 1$. First, we modify the conditions to contain non strict inequalities with the same 
direction:\break 
$Y^g_{dp} \leq 0 \wedge X^g_{dp} = 0$ or $-Y^g_{dp} \leq -1  \wedge X^g_{dp} = 1$. Then, we introduce a dummy constant $\mu$ with a large value, which is a coefficient for $X^g_{dp}$ variable.
When $X^g_{dp} = 0$, then the equation \ref[eq:model:mip:xy:1] becomes $Y^g_{dp} \leq 0$ and the equation \ref[eq:model:mip:xy:2] becomes $-Y^g_{dp} \leq -1 + \mu$. Since $\mu$ is a large number,
the second constraint is always satisfied and only the first one is acting. Similarly, when $X^g_{dp} = 1$ then the first constraint is allways satisfied and the second one is acting.
%First, we split the equivalence into two statements,  $Y^g_{dp} - X^g_{dp} \leq 0$

\secc Variations of the MIP based model

\sec MIP solver

To solve MIP based problem, we use a state of the art solver, just like in the case of CSP based problem. We use a solver SCIP \cite[Achterberg2008], which is wrapped for Java langauage
in OR-tools developed by Google \cite[Perron2011]. The SCIP system is one of the fastest non-commercial solvers for mixed integer programming \cite[Mittelmann2014].

The SCIP system is freely available only for non-commercial use. Although, the OR-tools provide a general interface for linear solvers, therefore, we can simply switch the underlying solver system.
However, since the interface is general, it does not provide a way to send information about the problem to the solver, as we did in case of CSP solver.


